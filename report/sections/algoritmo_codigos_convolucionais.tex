\section{Algoritmos para códigos convolucionais}
A algoritmo desenvolvido pode ser dividido nas seguintes etapas: codificação, e decodificação. Cada uma dessas etapas esta descrita nas subseções seguintes.

\subsection{Codificação}

% DIFICULDADES PARA IMPLMENTAR CODIFICADOR

A codificação consistiu processar os bits de entrada pela máquina de estado descrita pelos polinômios geradores fornecidos, descritos pela Tabela \ref{tab:polinomios_geradores}. $m$ indica a quantidade de memórias da máquina, e, consequentemente, o número de estados que ela pode atingir.

\begin{table}[h!]
	\centering
	\caption{Polinômios geradores na forma octal}
	\label{tab:polinomios_geradores}
	\begin{tabular}{|c|c|c|c|}
		\hline
		$m$ & $g1(D)$ & $g2(D)$ & $g3(D)$ \\ \hline\hline
		 3  &   13    &   15    &   17    \\ \hline
		 4  &   25    &   33    &   37    \\ \hline
		 6  &   117   &   127   &   155   \\ \hline
	\end{tabular} 
\end{table}

Partindo do estado nulo, o processamento da máquina consiste em dado um bit, gerar 3 bits codificados de acordo com o valor armazenado nas $m$ memórias e os polinômios geradores, deslocar o valor das memórias, e então o bit recebido passa a ocupar a primeira memória. Dessa forma, o código possui taxa $1/3$.

%Sendo $G(D)$ uma matriz cujas linhas representam os polinômios geradores e $u(D)$ a mensagem a ser transmitida. Matematicamente, a mensagem codificada, $v(D)$, pode ser interpretado como descrito em (\ref{eq:mensagem_codificada}).
%
%\begin{equation}
%	s(D) = u(D).G(D)
%\end{equation}
%
%\begin{equation}
%	v(D) = \sum_{i=1}^{n} s_{i}(D^{n})D^{i-1}
%	\label{eq:mensagem_codificada}
%\end{equation}


\subsection{Decodificação}

Nesta parte do experimento é necessário utilizar o algoritmo de Viterbi para realizar a decodificação do código gerado. A ideia por trás desse algoritmo é armazenar os custos dos caminhos possíveis, a partir do estado nulo, de acordo com a mensagem transmitida. O custo de um caminho é obtido pela soma dos custos dos ramos que formam o percurso.

Para evitar, crescer exponencialmente com as possibilidades de percursos, o algoritmo de Viterbi aproveita-se do fato que vários percursos levam a um mesmo estado. Assim, pode-se escolher apenas o percurso mais provável para aquele estado um instante de tempo. Como critério é usado que o caminho mais provável é o com menor custo, pois está sendo adotado que o canal tem maior taxa de acerto.

Para decidir a sequencia correta que foi transmitida foi implementado o algoritmo de Viterbi já descrito. O pseudocódigo para tal algoritmo é mostrado em Algoritmo \ref{alg:viterbi}.

\begin{algorithm}[h!]
	\caption{Decodificação}
	\label{alg:viterbi}
	\begin{algorithmic}[Message]		
		\Procedure{$decode$}{$message$}
			\State $Custo[0] \gets 0$
			\State $Custo[i] \gets \infty, \forall i \ne 0$
			
			\For {$simb \in message$}
				\For {$Estados futuro - f$}
					\State $Custo[f] \gets min(Custo[i] + trans(i, f, simb))$
				\EndFor
			\EndFor
			
			\State {$x \gets min(Custo)$}					
			
		\Return $caminho[x]$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Para calcular o custo de determinada transição é usado a distância de Hamming entre o simbolo recebido e o simbolo associado à transição. O Algoritmo \ref{alg:hamming} apresenta o pseudocódigo para esse caso.

\begin{algorithm}[h!]
	\caption{Distância de Hamming}
	\label{alg:hamming}
	\begin{algorithmic}[Message]		
		\Procedure{$hamming$}{$inicial$, $final$, $simb$}
		\State $esperado \gets simbolo(inicial, final)$
		\State $custo = 0$
		
		\For {$i \in len(simb)$}
			\State $custo += simb[i] + esperado[i] \% 2$
		\EndFor
		
		\Return $custo$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

A fim de obter melhores resultados para a decodificação é possível realizar algumas alteração no algoritmo de Viterbi. Duas dessas possíveis alterações são descritas nas subseções seguintes.

\subsubsection{Primeira variação}

A primeira alteração no algoritmo de Viterbi consiste em usar o valor real, sem aproximação, de $\log(P[s|r])$. 

Ao calcular $\log(P[s|r])$ obtemos uma expressão da forma:

\begin{equation}
	\log(P[s|r]) \propto a\log[1-p] + b\log[p]
\end{equation}

para valores pequenos de $p$ o termo $\log[1-p]$ pode ser aproximado para $0$, fornecendo a aproximação usado inicialmente. Porém, para valores mais significativos de $p$ esse termo não se torna desprezível.

O Algoritmo \ref{alg:exact} apresenta o pseudocódigo para o calculo do custo utilizando a primeira variação.

\begin{algorithm}[h!]
	\caption{Distância Exata}
	\label{alg:exact}
	\begin{algorithmic}[Message]		
		\Procedure{$exact$}{$inicial$, $final$, $simb$, $p$}
		\State $h = hamming(inicial, final, simb)$
		
		\State $custo = h.\log[p] + (len(simb) - h).\log[1-p]$
			
		\Return $custo$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Vale ressaltar que agora é necessário obter o caminho de custo máximo visto que ao aplicar o $\log$ será obtido custos negativos. 

\subsubsection{Segunda variação}

A próxima alteração no algoritmo de Viterbi consiste em utilizar uma modulação digital BPSK através de um canal AWGN. 

Para realizar a modulação BPSK, realiza-se a seguinte conversão: os bits com valor $0$ se tornam $-1$ e os bits com valor $1$ são mantidos.

A transmissão pelo canal AWGN introduz um ruído Gaussiano Branco à mensagem transmitida. Para isso, insere-se o ruído como um sinal aleatório com média $\mu = 0$ e variância $\sigma^{2} = \frac{N_{0}}{2}$, em que $N_{0}$ se relaciona com a probabilidade de erro do canal por:

%% VERIFICAR FORMULA
\begin{equation}
	N_{0} = \frac{2}{R E_{i} (Q^{-1}(p))^{2}}
\end{equation}

Com isso, é necessário agora alterar a função de custo para calcular a distância euclidiana entre o o simbolo recebido e o simbolo esperado. O pseudocódigo para essa alteração é mostrado no Algoritmo \ref{alg:euclidean}.

\begin{algorithm}[h!]
	\caption{Distância Euclidiana}
	\label{alg:euclidean}
	\begin{algorithmic}[Message]		
		\Procedure{$euclidean$}{$inicial$, $final$, $simb$}
		\State $esperado \gets simbolo(inicial, final)$
		\State $custo = 0$
		
		\For {$i \in len(simb)$}
		\State $custo += (simb[i] - esperado[i])^{2}$
		\EndFor
		
		\Return $custo$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

A decisão do caminho ótimo é realizada com base no percurso com menor custo final.

